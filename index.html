<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>ğŸ£ å¯æ„›é»˜æ›¸ Dictation</title>
  <style>
    /* å›ºå®š pxï¼Œç¢ºä¿æ‰‹æ©Ÿ/æ¡Œé¢ä¸€è‡´ */
    html, body { font-size: 18px; line-height: 1.5; }
    body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, "PingFang HK", "PingFang TC", "Microsoft JhengHei", sans-serif; background: linear-gradient(135deg,#fdf2ff,#e6f7ff); }
    .wrap { max-width: 960px; margin: 0 auto; padding: 16px; }

    /* å¯æ„›å¡ç‰‡é¢¨æ ¼ */
    .card { background: #fff; border-radius: 16px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); padding: 16px; margin: 12px 0; }
    .header { display:flex; align-items:center; gap:12px; }
    .title { font-size: 26px; font-weight: 800; }
    .chip { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#ffeef7; color:#d63384; font-size: 14px; }

    .row { display:flex; flex-wrap: wrap; gap:12px; align-items:center; margin: 10px 0; }
    textarea { width:100%; height: 160px; box-sizing:border-box; font-size:18px; padding:12px; border-radius:12px; border:2px solid #ffe3f0; background:#fff8fb; }

    .btn { font-size:18px; padding:12px 20px; min-width:120px; min-height:48px; border:none; border-radius:12px; color:#fff; background:#ff7aa2; cursor:pointer; box-shadow: 0 4px 12px rgba(255,122,162,0.35); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background:#6c8cff; box-shadow: 0 4px 12px rgba(108,140,255,0.35); }
    .btn.warn { background:#ff8b6c; box-shadow: 0 4px 12px rgba(255,139,108,0.35); }
    .btn.smol { min-width: 90px; padding: 10px 14px; font-size: 16px; }

    label { font-weight: 700; }
    select, input[type="number"] { font-size:18px; padding:10px 12px; border-radius:10px; border:2px solid #e9f0ff; background:#f7fbff; }
    .no-shrink { flex-shrink:0; }

    .section-title { font-size: 18px; font-weight: 800; margin-bottom: 8px; }
    .hr { height:1px; background:#f0f0f0; margin: 14px 0; }

    .status { font-weight: 800; color:#5f6eff; background:#eef0ff; border-radius: 999px; padding: 6px 10px; }
    .muted { color:#666; }

    .pill { display:inline-flex; align-items:center; gap:6px; background:#fff; border:2px dashed #ffd1e2; border-radius: 999px; padding: 8px 12px; }

    /* æ–°å¢ï¼šå¿«é€Ÿé‡æ’­æ–¹æ ¼ */
    .gridWords { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; }
    .chipWord { font-size:16px; padding:10px 12px; border:2px solid #ffd1e2; background:#fff; border-radius:999px; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,0.04); }
    .chipWord:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div style="font-size:30px">ğŸˆğŸ£âœ¨</div>
        <div class="title">å¯æ„›é»˜æ›¸ Dictation</div>
        <span class="chip">ä¸­è‹±çš†å¯ Â· ç²µèªæœ—è®€ Ã—3ï¼ˆå¯è‡ªé¸æ¬¡æ•¸ï¼‰</span>
      </div>
      <div class="row" style="margin-top:6px">
        <div class="muted">è¼¸å…¥ä¸­æ–‡æˆ–è‹±æ–‡è©èªï¼ˆé€—è™Ÿæˆ–æ¯è¡Œä¸€å€‹ï¼‰</div>
      </div>
      <textarea id="wordInput" placeholder="ä¾‹ï¼š\nå°‹å¯¶\nè¶…ç´šå¸‚å ´\napple, banana, orange"></textarea>

      <div class="hr"></div>
      <div class="section-title">â±ï¸ è¨­å®š</div>
      <div class="card" style="background:#fffefe">
        <div class="row">
          <label for="countdown">é–‹å§‹å‰å€’æ•¸ï¼ˆ0â€“10 ç§’ï¼‰ï¼š</label>
          <select id="countdown" class="no-shrink">
            <option value="0">0</option><option value="1">1</option><option value="2">2</option>
            <option value="3" selected>3</option><option value="4">4</option><option value="5">5</option>
            <option value="6">6</option><option value="7">7</option><option value="8">8</option>
            <option value="9">9</option><option value="10">10</option>
          </select>
        </div>
        <div class="row">
          <label for="repeatGap">åŒä¸€è©èªçš„æœ—è®€é–“éš”ï¼ˆ3â€“10 ç§’ï¼‰ï¼š</label>
          <select id="repeatGap" class="no-shrink">
            <option value="3" selected>3</option><option value="4">4</option><option value="5">5</option>
            <option value="6">6</option><option value="7">7</option><option value="8">8</option>
            <option value="9">9</option><option value="10">10</option>
          </select>
        </div>
        <div class="row">
          <label for="wordGap">è©èªä¹‹é–“çš„é–“éš”ï¼ˆ3â€“15 ç§’ï¼‰ï¼š</label>
          <select id="wordGap" class="no-shrink">
            <option value="3" selected>3</option><option value="4">4</option><option value="5">5</option>
            <option value="6">6</option><option value="7">7</option><option value="8">8</option>
            <option value="9">9</option><option value="10">10</option><option value="11">11</option>
            <option value="12">12</option><option value="13">13</option><option value="14">14</option><option value="15">15</option>
          </select>
        </div>
        <div class="row">
          <label for="repeatCount">æ¯å€‹è©èªé‡è¤‡æ¬¡æ•¸ï¼ˆ1â€“5 æ¬¡ï¼‰ï¼š</label>
          <select id="repeatCount" class="no-shrink">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3" selected>3</option>
            <option value="4">4</option>
            <option value="5">5</option>
          </select>
        </div>
        <div class="row">
          <label for="rateSelect">èªé€Ÿï¼ˆ0.7â€“1.3ï¼‰ï¼š</label>
          <select id="rateSelect" class="no-shrink">
            <option value="0.7">0.7ï¼ˆè¼ƒæ…¢ï¼‰</option>
            <option value="0.85">0.85</option>
            <option value="1.0" selected>1.0ï¼ˆæ­£å¸¸ï¼‰</option>
            <option value="1.1">1.1</option>
            <option value="1.2">1.2ï¼ˆè¼ƒå¿«ï¼‰</option>
            <option value="1.3">1.3ï¼ˆæ›´å¿«ï¼‰</option>
          </select>
        </div>
        <div class="row">
          <label for="langMode">èªéŸ³æ¨¡å¼ï¼š</label>
          <select id="langMode" class="no-shrink">
            <option value="auto" selected>è‡ªå‹•ï¼ˆä¸­æ–‡â†’ç²µèªã€è‹±æ–‡â†’è‹±èªï¼‰</option>
            <option value="yue">å…¨éƒ¨ç”¨ç²µèª</option>
            <option value="en">å…¨éƒ¨ç”¨è‹±èª</option>
          </select>
        </div>
      </div>

      <div class="hr"></div>
      <div class="section-title">ğŸ—£ï¸ èªéŸ³ï¼ˆåªä¿ç•™æ›´è‡ªç„¶çš„è‹±èªï¼‰</div>
      <div class="card" style="background:#f7fbff;border:2px solid #e9f0ff">
        <div class="row">
          <div class="pill">
            <span>ğŸ‡­ğŸ‡° ç²µèªèªéŸ³ï¼š</span>
            <select id="voiceYue" class="no-shrink"></select>
            <button id="testYue" class="btn smol secondary">è©¦è½</button>
          </div>
        </div>
        <div class="row">
          <div class="pill">
            <span>ğŸ‡¬ğŸ‡§/ğŸ‡ºğŸ‡¸ è‹±èªèªéŸ³ï¼ˆç™½åå–®ï¼‰ï¼š</span>
            <select id="voiceEn" class="no-shrink"></select>
            <button id="testEn" class="btn smol secondary">è©¦è½</button>
          </div>
          <div class="muted">ä¿ç•™ï¼šGoogle US/UK Englishã€Microsoft Aria/Soniaã€iOS Samantha/Karen</div>
        </div>
      </div>

      <div class="hr"></div>
      <div class="section-title">âœ¨ å¿«é€Ÿé‡æ’­ï¼ˆé»é¸ä»»ä½•è©èªï¼‰</div>
      <div id="gridWords" class="gridWords card" style="padding:12px;"></div>

      <div class="hr"></div>
      <div class="row">
        <button id="startBtn" class="btn no-shrink">ğŸŸ£ é–‹å§‹</button>
        <button id="stopBtn" class="btn warn no-shrink" disabled>ğŸ›‘ åœæ­¢</button>
        <span id="status" class="status">å¾…å‘½</span>
      </div>
      <div class="row"><span class="muted">é è¦½ï¼š</span><span id="preview" class="muted">ï¼ˆæ²’æœ‰å…§å®¹ï¼‰</span></div>
    </div>
  </div>

  <script>
    // --- Utilities ---
    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
    function isCJK(s){ return /[\u3400-\u9FFF\uF900-\uFAFF]/.test(s); }
    function parseWords(raw){ return raw.split(/\n|,|ï¼Œ|ï¼›|;|\t/).map(w=>w.trim()).filter(Boolean); }

    // --- Elements ---
    const wordInput = document.getElementById('wordInput');
    const countdown = document.getElementById('countdown');
    const repeatGap = document.getElementById('repeatGap');
    const wordGap = document.getElementById('wordGap');
    const repeatCount = document.getElementById('repeatCount');
    const rateSelect = document.getElementById('rateSelect');
    const langMode = document.getElementById('langMode');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');
    const voiceYueSel = document.getElementById('voiceYue');
    const voiceEnSel = document.getElementById('voiceEn');
    const testYueBtn = document.getElementById('testYue');
    const testEnBtn = document.getElementById('testEn');
    const gridWords = document.getElementById('gridWords');

    const SETTINGS_KEY = 'cute_dictation_settings_v4';

    function updatePreview(){
      const list = parseWords(wordInput.value);
      preview.textContent = list.length ? list.join(' Â· ') : 'ï¼ˆæ²’æœ‰å…§å®¹ï¼‰';
      renderGrid(list);
    }
    wordInput.addEventListener('input', ()=>{ updatePreview(); saveSettings(); });

    // --- Voice preferences (DECLARE BEFORE USE) ---
    const preferEnOrder = [
      /microsoft aria.*english \(united states\)/i,
      /microsoft sonia.*english \(great britain\)/i,
      /google uk english/i,
      /google us english/i,
      /samantha/i, // iOS en-US
      /karen/i     // iOS en-AU
    ];
    const whitelistEn = [
      /google (us|uk) english/i,
      /microsoft aria.*english/i,
      /microsoft sonia.*english/i,
      /samantha/i,
      /karen/i
    ];

    // --- SpeechSynthesis voices ---
    let voices = [];

    function bestEnglish(voices){
      const list = voices.filter(v => /^en/i.test(v.lang) && whitelistEn.some(rx => rx.test((v.name + ' ' + v.lang))));
      for(const rule of preferEnOrder){
        const hit = list.find(v => rule.test((v.name + ' ' + v.lang)));
        if(hit) return hit;
      }
      return list[0] || null;
    }

    function bestCantonese(voices){
      const yue = voices.filter(v => /yue|zh[-_]?HK|cantonese|ç²µ/.test((v.lang + ' ' + v.name).toLowerCase()));
      if (yue[0]) return yue[0];
      const zh = voices.filter(v => /zh[-_](hk|tw|mo)|hant/i.test(v.lang));
      return zh[0] || null;
    }

    function renderVoiceOptions(){
      voiceYueSel.innerHTML = '';
      voiceEnSel.innerHTML = '';

      voices.forEach((v, idx)=>{
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = `${v.name} (${v.lang})`;
        if (/yue|zh[-_]?HK|cantonese|ç²µ|zh[-_]tw|hant/i.test((v.lang + ' ' + v.name))) {
          voiceYueSel.appendChild(opt.cloneNode(true));
        }
        if (/^en/i.test(v.lang) && whitelistEn.some(rx => rx.test((v.name + ' ' + v.lang)))) {
          voiceEnSel.appendChild(opt);
        }
      });

      // defaults
      const bYue = bestCantonese(voices);
      const bEn  = bestEnglish(voices);
      if (bYue){
        const yOpt = Array.from(voiceYueSel.options).find(o=>voices[o.value|0]===bYue);
        if (yOpt) yOpt.selected = true;
      }
      if (bEn){
        const eOpt = Array.from(voiceEnSel.options).find(o=>voices[o.value|0]===bEn);
        if (eOpt) eOpt.selected = true;
      }

      // restore saved indices
      const saved = loadSettings();
      if (saved) {
        if (saved.voiceYueIndex != null && voices[saved.voiceYueIndex]) {
          const yOpt = Array.from(voiceYueSel.options).find(o => (o.value|0) === saved.voiceYueIndex);
          if (yOpt) yOpt.selected = true;
        }
        if (saved.voiceEnIndex != null && voices[saved.voiceEnIndex]) {
          const eOpt = Array.from(voiceEnSel.options).find(o => (o.value|0) === saved.voiceEnIndex);
          if (eOpt) yOpt && (eOpt.selected = true);
        }
      }
    }

    function loadVoices(){
      voices = window.speechSynthesis.getVoices();
      renderVoiceOptions();
    }
    window.speechSynthesis.onvoiceschanged = loadVoices;

    function speakOnce(text, mode){
      return new Promise(resolve=>{
        const u = new SpeechSynthesisUtterance(text);
        let voice = null;
        const rate = parseFloat(rateSelect.value) || 1.0;
        if (mode === 'yue') {
          const idx = voiceYueSel.value|0; voice = voices[idx] || bestCantonese(voices);
          if (voice) u.voice = voice; u.lang = voice ? voice.lang : 'zh-HK'; u.rate = rate; u.pitch = 1.0;
        } else if (mode === 'en') {
          const idx = voiceEnSel.value|0; voice = voices[idx] || bestEnglish(voices);
          if (voice) u.voice = voice; u.lang = voice ? voice.lang : 'en-US'; u.rate = rate; u.pitch = 1.0;
        } else {
          if (isCJK(text)) {
            const idx = voiceYueSel.value|0; voice = voices[idx] || bestCantonese(voices);
            if (voice) u.voice = voice; u.lang = voice ? voice.lang : 'zh-HK'; u.rate = rate; u.pitch = 1.0;
          } else {
            const idx = voiceEnSel.value|0; voice = voices[idx] || bestEnglish(voices);
            if (voice) u.voice = voice; u.lang = voice ? voice.lang : 'en-US'; u.rate = rate; u.pitch = 1.0;
          }
        }
        u.onend = resolve; window.speechSynthesis.speak(u);
      });
    }

    testYueBtn.addEventListener('click', ()=>{
      const text = 'ä½ å¥½ï¼Œæ¸¬è©¦ç²µèªç™¼éŸ³ã€‚';
      speakOnce(text, 'yue');
    });
    testEnBtn.addEventListener('click', ()=>{
      const text = 'Hello! This is a natural English voice test.';
      speakOnce(text, 'en');
    });

    // --- å¿«é€Ÿé‡æ’­é‚è¼¯ ---
    const priorityQueue = [];
    function renderGrid(list){
      gridWords.innerHTML = '';
      list.forEach(w => {
        const b = document.createElement('button');
        b.className = 'chipWord';
        b.textContent = w;
        b.title = 'é»æˆ‘ï¼šç«‹å³é‡æ’­æ­¤è©èªï¼ˆä¾è¨­å®šé‡è¤‡æ¬¡æ•¸ï¼‰';
        b.addEventListener('click', ()=>{
          priorityQueue.push(w);
          statusEl.textContent = 'å·²åŠ å…¥é‡æ’­ï¼š'+w;
        });
        gridWords.appendChild(b);
      });
    }

    async function processPriorityIfAny(rGapMs){
      const repeatN = Math.min(5, Math.max(1, parseInt(repeatCount.value,10) || 3));
      while(priorityQueue.length){
        const w = priorityQueue.shift();
        const mode = langMode.value;
        statusEl.textContent = 'å¿«é€Ÿé‡æ’­ï¼š'+w;
        for(let r=0;r<repeatN;r++){
          await speakOnce(w, mode);
          if (r<repeatN-1){ const until = Date.now()+rGapMs; while(Date.now()<until){ await sleep(30);} }
        }
      }
    }

    // --- Run logic ---
    function setUIRunning(r){
      startBtn.disabled = r; stopBtn.disabled = !r;
      // å…è¨±é–‹å§‹å¾Œä»å¯è¼¸å…¥æ–°è©èª
      countdown.disabled = r; repeatGap.disabled = r; wordGap.disabled = r; repeatCount.disabled = r; rateSelect.disabled = r; langMode.disabled = r;
      voiceYueSel.disabled = r; voiceEnSel.disabled = r; testYueBtn.disabled = r; testEnBtn.disabled = r;
    }

    let stopFlag = false;

    async function run(){
      if (!parseWords(wordInput.value).length){ alert('è«‹å…ˆè¼¸å…¥è©èª'); return; }
      saveSettings();
      stopFlag = false; setUIRunning(true);

      let cd = parseInt(countdown.value,10)||0;
      for(let t=cd; t>0; t--){ if (stopFlag) break; statusEl.textContent = 'å€’æ•¸ï¼š'+t; await sleep(1000); }
      if (stopFlag){ statusEl.textContent='å·²åœæ­¢'; setUIRunning(false); return; }
      statusEl.textContent='é–‹å§‹';

      const rGap = (parseInt(repeatGap.value,10)||3)*1000;
      const wGap = (parseInt(wordGap.value,10)||3)*1000;
      const mode = langMode.value;
      const repeatN = Math.min(5, Math.max(1, parseInt(repeatCount.value,10) || 3));

      for(let i=0; ; i++){
        const list = parseWords(wordInput.value);
        if (i >= list.length) break;
        if (stopFlag) break; const w = list[i];
        statusEl.textContent = 'æœ—è®€ï¼š'+w+'  ('+(i+1)+'/'+list.length+')';
        for(let r=0;r<repeatN;r++){
          if (stopFlag) break; await speakOnce(w, mode);
          if (r<repeatN-1){ const until = Date.now()+rGap; while(Date.now()<until){ if(stopFlag) break; await processPriorityIfAny(120); await sleep(30); } }
        }
        if (stopFlag) break;
        if (i<list.length-1){ statusEl.textContent='é–“éš”ä¸­â€¦ ('+Math.round(wGap/1000)+'s)'; const untilW=Date.now()+wGap; while(Date.now()<untilW){ if(stopFlag) break; await processPriorityIfAny(120); await sleep(30);} }
      }

      // å®Œæˆå‰ï¼Œè™•ç†ä»»ä½•å°šæœªæ’­æ”¾çš„å¿«é€Ÿé‡æ’­
      await processPriorityIfAny(120);

      if(!stopFlag) statusEl.textContent='å®Œæˆ';
      setUIRunning(false);
    }

    startBtn.addEventListener('click', run);
    stopBtn.addEventListener('click', ()=>{ stopFlag = true; try{ speechSynthesis.cancel(); }catch(e){} statusEl.textContent='å·²åœæ­¢'; setUIRunning(false); });

    // --- Save/Load settings ---
    function saveSettings(){
      const data = {
        countdown: countdown.value,
        repeatGap: repeatGap.value,
        wordGap: wordGap.value,
        repeatCount: repeatCount.value,
        rate: rateSelect.value,
        langMode: langMode.value,
        words: wordInput.value,
        voiceYueIndex: voiceYueSel.value|0,
        voiceEnIndex: voiceEnSel.value|0
      };
      localStorage.setItem(SETTINGS_KEY, JSON.stringify(data));
    }
    function loadSettings(){
      try{
        const raw = localStorage.getItem(SETTINGS_KEY); if(!raw) return null;
        const data = JSON.parse(raw);
        countdown.value = data.countdown || countdown.value;
        repeatGap.value = data.repeatGap || repeatGap.value;
        wordGap.value = data.wordGap || wordGap.value;
        repeatCount.value = data.repeatCount || repeatCount.value;
        rateSelect.value = data.rate || rateSelect.value;
        langMode.value = data.langMode || langMode.value;
        wordInput.value = data.words || wordInput.value; updatePreview();
        return data;
      }catch(e){ return null; }
    }

    [countdown, repeatGap, wordGap, repeatCount, rateSelect, langMode, wordInput, voiceYueSel, voiceEnSel].forEach(el=>{
      el.addEventListener('change', saveSettings);
      el.addEventListener('input', saveSettings);
    });

    // Initial load
    loadVoices();
    loadSettings();
    updatePreview();

    // --- Minimal console tests (do not affect UI) ---
    (function(){
      try {
        // Test whitelist
        const mockVoices = [
          { name:'Random Voice', lang:'en-GB' },
          { name:'Google UK English', lang:'en-GB' },
          { name:'Microsoft Aria Online (Natural) - English (United States)', lang:'en-US' },
          { name:'Samantha', lang:'en-US' },
          { name:'Karen', lang:'en-AU' },
        ];
        const whitelistEn = [/google (us|uk) english/i,/microsoft aria.*english/i,/microsoft sonia.*english/i,/samantha/i,/karen/i];
        const whitelisted = mockVoices.filter(v => /^en/i.test(v.lang) && whitelistEn.some(rx => rx.test((v.name + ' ' + v.lang))));
        console.assert(whitelisted.length === 4, '[TEST] whitelistEn æ‡‰è©²åªä¿ç•™ 4 å€‹è‹±èªè²ç·š');

        // Test repeat count bounds
        const testVals = [0,1,3,5,9];
        const clamped = testVals.map(v=> Math.min(5, Math.max(1, v)));
        console.assert(JSON.stringify(clamped) === JSON.stringify([1,1,3,5,5]), '[TEST] repeat count æ‡‰åœ¨ 1~5 ä¹‹é–“');
      } catch (e) { console.error('[TEST] Error running tests:', e); }
    })();
  </script>
</body>
</html>
